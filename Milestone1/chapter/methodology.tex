\chapter{Methodology} \label{ch:methodology}
    \section{Software Developement Methodologies}
        \subsection{Development Methodology}
            Due to the nature of our team and project. We thought it best to implement an agile based development
            methodology. As a small team, it is easy for us to communicate with each other about the project, and easier
            for us to be aware of what the other members of our team are doing, key factors for choosing an agile
            methodology. 
            
            The question then is, which agile based methodology to use? There are a variety of
            methodologies our there each with their own pros and cons, which we will address some of which shortly. But
            based on these we decided to use a scrum-based development methodology. Scrum is a combination of iterative
            and incremental development. Allowing for a best of both worlds approach of having early builds working, but
            also being agile and able to add requirements during the development process~\cite{srivastava_2017_scrum}.
            
            The scrum methodology is rather simple. To effectively work, it requires collaboration between an appointed
            ‘Scum Master’ and the rest of the team, as well as a ‘Product Owner’. These members will work in close
            collaboration other multiple, continuous iterations of the software build to create a finished product. The
            role of the scrum master is to eliminate impediments~\cite{srivastava_2017_scrum}or in other terms, to
            create the conditions that allow the development team to work in their most effective manner, they take a
            leading role in choosing what sprints the team work on. 
            
            A typical scrum workflow consists of iterative scrum
            cycles, typically lasting one to three weeks each. Initially a requirements backlog is created.  This is
            done in collaboration with the client and is the documentation that describes all the requirements that the
            software must meet. It is essentially a description of the product that the team are aiming to build. Once
            an initial backlog is created, the scrum cycles can start. As before mentioned, each scrum cycle lasts
            typically up to three weeks. The cycle kicks of with the team, headed by the scrum master deciding which
            requirements to prioritise and implement in the upcoming cycle. The aim is to have a potentially shippable
            product at the end of each sprint, although this may not be possible immediately. Once the team have
            allocated the suitable requirements to the sprint, the sprint begins, the team works on the product, meeting
            each day in what are known as ‘scrums’ to review progress made on each day. At the end of the sprint, the
            team should have made a shippable product. The team will also meet and hold a sprint review, along with the
            product owner. That demonstrates the product and how it has been developed since the last sprint. The team
            will also review the previous sprint, to see if any changes need to be made in anticipation of the next
            one~\cite{nuevo_2011_scrumbased}.
            
            In our case, we will be slightly modifying the implementation of scrum.
            The above-mentioned workflow is designed as a framework for full time software developers, which we are not.
            As much as we may perhaps wish too, we will not be able to meet daily to discuss the project. As students it
            is an unrealistic expectation that we will be able to hold daily scrums, but we can still follow the
            methodology. We will aim to hold scrums at frequent intervals, in periods perhaps of every week, to keep
            tabs on the current sprints running. We can also compensate for this by being realistic in what we can
            achieve, and what we set as the sprint’s goals. 
            
            Ultimately, we chose to use scrum for a variety of reasons.
            Primarily of all, we realised that as a small team, frequent communication would be easy to achieve, so we
            would be able to make use of this framework in the most effective manner, compared to other methodologies.
            We would be able to meet frequently and use that to ensure progress is made on the project. Scrum works well
            with this. Using scrum would enable us to work together to frequently get working products out and allow us
            to put ourselves in a position to implement more features. We also feel that using scrum would allow us to
            have a higher quality product, as the frequent iterations during sprints would allow us to streamline our
            implementation and constantly improve it. It also allows us to minimise risk. Take the waterfall methodology
            for example, where implementation begins a lot later in the lifecycle. Using scrum, where we start
            programming earlier, gives us more time to deal with any difficulties we encounter. It allows us to spot
            problems earlier, have longer to address them, or to have time to plan alternative implementations that
            avoid such problems. 
            
            We chose scrum over other agile methodologies for a few reasons, but mainly because we
            thought it was the best fit for our team and situation. Other methodologies, like extreme programming, could
            have worked well for us, but didn’t suit our situation as students as well. For example, extreme programming
            requires pair programming, something that would be hard for us to do and would drastically tank our
            productivity. Overall, we made our decision based on what would work best for us as a team.

    
        \subsection{Hardware}
            We have chosen to base our hardware on the TinyPico implementation of the Espressif Systems ESP32 family of
            devices.\ This is mainly due to our experience with the platform, including previous university modules
            experimenting with these microcontrollers.\ To compliment the TinyPico, we will need to include an array of
            input sensors, as well as ways to output information to the user.\ In order to detect movement, we will rely
            on accelerometer data from the pervasive ADXL family of accelerometers, namely the ADXL345 due to its
            reliable and proven performance, as well as its easy availability and team members' experience with the
            device.\ Beyond what's available on the TinyPico, we may also require additional methods of receiving and
            transiting data to and from our wearable device and the walking aid device, we have a few technologies we
            are considering, such as 433MHz Rx/Tx, or the proprietary LoRa communication system if the budget allows for
            it.

            For outputs, the wearable device will need an output LED that may be handled by the TinyPico itself, or most
            likely an external low voltage LED to allow for more flexible placement, furthermore, it will need support
            for vibration feedback, which will likely come in the format of a mobile phone style vibration motor.\ This
            will ensure the users are not startled, due to its lower power and smaller size The walking aid device will
            require to have a small speaker as an output, in order to prompt the user to use their walking aid.\ We can
            then either include a microphone onboard the device to record and store data to the onboard TinyPico
            storage, or support the use of an external SD card to access a prerecorded message.

            One of the group members has access to a 3D Printer and has experience in 3D Design, and such we will be
            able to rapidly develop and test chassis and shells for our sensors, to more close resemble a finished
            proud whilst testing or demoing to our client.\ This is crucial due to the importance of the form factor
            and readability of the devices, as previously discussed in the document, such as minimising patient discomfort.

            The TinyPico form factor is incredibly compact, and would be viable for the NONFREQ1 requirement.\ This also
            extends to the input and output sensors, which we also believe would easily fit on a wearable or walking aid
            based device.\ The low power consumption of the TinyPico and sensors,  will help us ensure NONFREQ2 and
            NONFREQ3 are met.\ This can be further exploited by implementing deep sleep algorithms within the TinyPico's
            routine, further reducing power consumption thus extending battery life on a single charge.

        \subsection{Software}
            Whilst working on the project, our team will use a plethora of services to assist in communication and
            management of the project.\ We have decided to use the Discord platform to keep in touch and communicate.
            This allows us to organise our channels and information streams accordingly, and even has essential tools
            for peer-development such as voice/video calls, with screen sharing support.\ We started a git repository on
            GitHub, which is where our source code and work towards our project deliverables will be.\ This version
            control software allows us all to work on the tasks together or independently, and for progress to be easily
            managed, tracked and merged with everyone else's work.

            Our milestones and written deliverables will be written in Latex, and stored on the GitHub to allow each
            team member to use the IDE or editing environment they are most familiar with, this ranges from Overleaf, to
            Intellij, to less specific editors like ATOM or SublimeText

            The TinyPico supports Arduino C, which is a subset of C with an essentially very similar, but tailored
            featureset and commandset.\ We have some experience with this in the past, however we will keep an open mind
            towards Micropython, which promises similar levels of performance and flexibility, in an arguably easier to
            learn and use language which we have more experience with.