\chapter{Methodology} \label{ch:methodology}
    \section{Software Developement Methodologies}
        \subsection{Development Methodology}
            Due to the nature of our team and project. We thought it best to implement an agile based development
            methodology. As a small team, it is easy for us to communicate with each other about the project, and easier
            for us to be aware of what the other members of our team are doing, key factors for choosing an agile
            methodology. 
            
            The question then is, which agile based methodology to use? There are a variety of
            methodologies our there each with their own pros and cons, which we will address some of which shortly. But
            based on these we decided to use a scrum-based development methodology. Scrum is a combination of iterative
            and incremental development. Allowing for a best of both worlds approach of having early builds working, but
            also being agile and able to add requirements during the development process~\cite{srivastava_2017_scrum}.
            
            The scrum methodology is rather simple. To effectively work, it requires collaboration between an appointed
            ‘Scum Master’ and the rest of the team, as well as a ‘Product Owner’. These members will work in close
            collaboration other multiple, continuous iterations of the software build to create a finished product. The
            role of the scrum master is to eliminate impediments~\cite{srivastava_2017_scrum}or in other terms, to
            create the conditions that allow the development team to work in their most effective manner, they take a
            leading role in choosing what sprints the team work on. 
            
            A typical scrum workflow consists of iterative scrum
            cycles, typically lasting one to three weeks each. Initially a requirements backlog is created.  This is
            done in collaboration with the client and is the documentation that describes all the requirements that the
            software must meet. It is essentially a description of the product that the team are aiming to build. Once
            an initial backlog is created, the scrum cycles can start. As before mentioned, each scrum cycle lasts
            typically up to three weeks. The cycle kicks of with the team, headed by the scrum master deciding which
            requirements to prioritise and implement in the upcoming cycle. The aim is to have a potentially shippable
            product at the end of each sprint, although this may not be possible immediately. Once the team have
            allocated the suitable requirements to the sprint, the sprint begins, the team works on the product, meeting
            each day in what are known as ‘scrums’ to review progress made on each day. At the end of the sprint, the
            team should have made a shippable product. The team will also meet and hold a sprint review, along with the
            product owner. That demonstrates the product and how it has been developed since the last sprint. The team
            will also review the previous sprint, to see if any changes need to be made in anticipation of the next
            one~\cite{nuevo_2011_scrumbased}. 
            
            In our case, we will be slightly modifying the implementation of scrum.
            The above-mentioned workflow is designed as a framework for full time software developers, which we are not.
            As much as we may perhaps wish too, we will not be able to meet daily to discuss the project. As students it
            is an unrealistic expectation that we will be able to hold daily scrums, but we can still follow the
            methodology. We will aim to hold scrums at frequent intervals, in periods perhaps of every week, to keep
            tabs on the current sprints running. We can also compensate for this by being realistic in what we can
            achieve, and what we set as the sprint’s goals. 
            
            Ultimately, we chose to use scrum for a variety of reasons.
            Primarily of all, we realised that as a small team, frequent communication would be easy to achieve, so we
            would be able to make use of this framework in the most effective manner, compared to other methodologies.
            We would be able to meet frequently and use that to ensure progress is made on the project. Scrum works well
            with this. Using scrum would enable us to work together to frequently get working products out and allow us
            to put ourselves in a position to implement more features. We also feel that using scrum would allow us to
            have a higher quality product, as the frequent iterations during sprints would allow us to streamline our
            implementation and constantly improve it. It also allows us to minimise risk. Take the waterfall methodology
            for example, where implementation begins a lot later in the lifecycle. Using scrum, where we start
            programming earlier, gives us more time to deal with any difficulties we encounter. It allows us to spot
            problems earlier, have longer to address them, or to have time to plan alternative implementations that
            avoid such problems. 
            
            We chose scrum over other agile methodologies for a few reasons. But mainly because we
            thought it was the best fit for our team and situation. Other methodologies, like extreme programming, could
            have worked well for us, but didn’t suit our situation as students as well. For example, extreme programming
            requires pair programming, something that would be hard for us to do and would drastically tank our
            productivity. Overall, we made our decision based on what would work best for us as a team.

    
        \subsection{Hardware and Software}
            With regards to hardware and software that we intend to use, we made our decisions based on the experience with
            hardware from previous work. For hardware, our product is going to be made using tiny PICO hardware. Multiple
            members of our group took the Embedded Systems module previously, so we have experience using this hardware. The
            tiny PICO on its own, does not have all the features we need, so we will be using extra hardware to supplement it.
            We will be using accelerometers to measure changes in movement of the dementia patients. We will also be
            implementing speakers and microphones to allow voice recordings to be created and played back. In the same vein, we
            will be using SD storage for storing sound files that can be played back. We also have access to a 3d printer, we
            will use this to create prototype casings for our product. It will enable us to rapidly design and test prototype
            products. This is important, as mentioned before in this document, the form factor of our product is important to
            minimise patient discomfort or resistiveness. Using 3d printing we can quickly test form factors and send prototype
            designs to our client quickly if they have a 3d printer too. This rapid prototyping will be beneficial, getting the
            right form factor is vitally important to ensure that the product is likely to be accepted by dementia patients It
            will help us meet requirement NONFREQ1. 
            
            We will be using a variety of software too. As is sensible with any product,
            we will be using git for version control and collaboration. Using git has a variety of benefits, version control,
            and enabling proper collaboration in the easiest way. It enables us to work on the same project without having to
            share resources. As mentioned, we are using TinyPICO devices as our hardware. Programming these devices is done in
            the Arduino C language, we will be using the Arduino IDE to program our product. Our document is created with latex,
            shared on git to enable us to collaborate and work on the document together. 
            
            With relation to our requirements, the
            hardware we use was chosen too directly meet the non-functional requirements that we defined. Tiny PICOs are
            incredibly small and can be fitted in very small form factors such as a watch which is in line with NONFREQ1.
            Accelerometers can also be made in small form factors too, which enables them to also fit in a small casing and help
            us meet our requirements. Tiny Picos are also power efficient, for example, they have various sleep modes that we
            can utilise to minimise power output, by avoiding using items such as LEDs, we can extend battery life, but also
            meet our requirement on not having obnoxious or startling lights or effects, these features help meet NONFREQ2 and
            3. We chose some of the other hardware to meet the functional requirements of the project. Accelerometers can detect
            if the user is walking, helping to meet FREQ 1. And the speaker we will use can play back messages to the user,
            meeting FREQ2. Storage and microphones also enable this requirement to be met.


    
